/**
 * Module Interaction - Gestion des √©v√©nements souris et clavier
 * @module interaction/events
 */

import { getCanvas, getCtx, screenToSpacetime } from '../renderer/canvas.js';
import { getConeAtPosition, getCartoucheAtPosition, checkIsochroneHover } from '../renderer/drawing.js';
import { getContainingCone } from '../physics/trajectory.js';
import { isReachableFromSource } from '../physics/relativity.js';
import { addConeAndDocument } from './controls.js';

// √âtats de drag & drop
let dragState = {
    isDragging: false,
    draggedConeIndex: -1,
    startX: 0,
    startY: 0,
    isNewCone: false,
    hasActuallyDragged: false
};

let cartoucheDragState = {
    isDragging: false,
    draggedConeIndex: -1,
    startX: 0,
    startY: 0,
    offsetX: 0,
    offsetY: 0
};

// Variables globales √† injecter
let coneOrigins = [];
let selectedReferenceFrame = 0;
let cartoucheOffsets = {};
let updateCalculationsDisplay = () => {};
let updateSelectedReferenceFrame = () => {};

/**
 * Initialise le module d'√©v√©nements
 * @param {Array} _coneOrigins - Origines des c√¥nes
 * @param {number} _selectedReferenceFrame - R√©f√©rentiel s√©lectionn√©
 * @param {Object} _cartoucheOffsets - Offsets des cartouches
 * @param {Function} _updateCalculationsDisplay - Fonction de mise √† jour
 * @param {Function} _updateSelectedReferenceFrame - Callback pour mettre √† jour le r√©f√©rentiel s√©lectionn√©
 */
export function initEventsModule(_coneOrigins, _selectedReferenceFrame, _cartoucheOffsets, _updateCalculationsDisplay, _updateSelectedReferenceFrame) {
    coneOrigins = _coneOrigins;
    selectedReferenceFrame = _selectedReferenceFrame;
    cartoucheOffsets = _cartoucheOffsets;
    updateCalculationsDisplay = _updateCalculationsDisplay;
    updateSelectedReferenceFrame = _updateSelectedReferenceFrame || (() => {});
}

/**
 * Convertit les coordonn√©es de souris en coordonn√©es relatives au canvas
 * @param {MouseEvent} event - √âv√©nement souris
 * @returns {{x: number, y: number}} Coordonn√©es relatives au canvas
 */
function getCanvasRelativeCoordinates(event) {
    const canvas = getCanvas();
    if (!canvas) return { x: 0, y: 0 };
    
    const rect = canvas.getBoundingClientRect();
    const relativeX = event.clientX - rect.left;
    const relativeY = event.clientY - rect.top;
    
    // Debug pour Chrome vs Safari
    console.log(`üñ±Ô∏è Mouse Debug:
        Client: (${event.clientX}, ${event.clientY})
        Canvas rect: left=${rect.left}, top=${rect.top}, width=${rect.width}, height=${rect.height}
        Relative: (${relativeX}, ${relativeY})
        Browser: ${navigator.userAgent.includes('Chrome') ? 'Chrome' : 'Safari/Other'}`);
    
    return {
        x: relativeX,
        y: relativeY
    };
}

/**
 * Gestionnaire d'√©v√©nement mousedown
 * @param {MouseEvent} event - √âv√©nement souris
 */
export function handleMouseDown(event) {
    const canvas = getCanvas();
    if (!canvas) return;
    
    const mouseCoords = getCanvasRelativeCoordinates(event);
    const mouseX = mouseCoords.x;
    const mouseY = mouseCoords.y;
    
    // V√©rifier si on clique sur un cartouche
    const cartoucheIndex = getCartoucheAtPosition(mouseX, mouseY, getCurrentPlacements());
    if (cartoucheIndex !== -1) {
        // Commencer le drag du cartouche
        cartoucheDragState.isDragging = true;
        cartoucheDragState.draggedConeIndex = cartoucheIndex;
        cartoucheDragState.startX = mouseX;
        cartoucheDragState.startY = mouseY;
        
        // Calculer l'offset depuis le coin sup√©rieur gauche du cartouche
        const placement = getCurrentPlacements().find(p => p.originalBox.coneIndex === cartoucheIndex);
        cartoucheDragState.offsetX = mouseX - placement.x;
        cartoucheDragState.offsetY = mouseY - placement.y;
        
        canvas.style.cursor = 'grabbing';
        return;
    }
    
    // V√©rifier si on clique sur une origine de c√¥ne
    const coneIndex = getConeAtPosition(mouseX, mouseY, coneOrigins);
    if (coneIndex !== -1) {
        // Commencer le drag du c√¥ne
        dragState.isDragging = true;
        dragState.draggedConeIndex = coneIndex;
        dragState.startX = mouseX;
        dragState.startY = mouseY;
        dragState.isNewCone = false;
        dragState.hasActuallyDragged = false;
        
        canvas.style.cursor = 'grabbing';
        return;
    }
    
    // V√©rifier si on clique √† l'int√©rieur d'un c√¥ne de lumi√®re
    const spacetime = screenToSpacetime(mouseX, mouseY);
    const sourceConeIndex = getContainingCone(spacetime.x, spacetime.t, coneOrigins);
    if (sourceConeIndex !== -1) {
        console.log('üöÄ Creating new cone from source cone:', sourceConeIndex);
        
        // Cr√©er un nouveau c√¥ne imm√©diatement √† la position du clic
        const spacetime = screenToSpacetime(mouseX, mouseY);
        const sourceCone = coneOrigins[sourceConeIndex];
        
        if (isReachableFromSource(spacetime.x, spacetime.t, sourceCone)) {
            const newCone = {
                x: spacetime.x,
                t: spacetime.t,
                sourceIndex: sourceConeIndex,
                cumulativeVelocity: 0,
                cumulativeProperTime: 0,
                totalCoordinateTime: spacetime.t
            };
            
            coneOrigins.push(newCone);
            const newConeIndex = coneOrigins.length - 1;
            console.log('‚úÖ Created new cone at:', spacetime.x.toFixed(2), spacetime.t.toFixed(2));
            // Documentation automatique (hors mode d√©mo)
            if (!window.isDemoMode) {
                addConeAndDocument(spacetime.x, spacetime.t);
            }
            // Maintenant commencer √† drag le nouveau c√¥ne cr√©√©
            dragState.isDragging = true;
            dragState.draggedConeIndex = newConeIndex;
            dragState.startX = mouseX;
            dragState.startY = mouseY;
            dragState.isNewCone = false; // C'est maintenant un c√¥ne existant qu'on drag
            dragState.hasActuallyDragged = false;
            
            // Mettre √† jour les calculs
            updateCalculationsDisplay();
            
            canvas.style.cursor = 'grabbing';
        } else {
            console.log('‚ùå Position not reachable from source cone');
        }
    } else {
        console.log('‚ùå Click outside all light cones');
    }
}

/**
 * Gestionnaire d'√©v√©nement mousemove
 * @param {MouseEvent} event - √âv√©nement souris
 */
export function handleMouseMove(event) {
    const canvas = getCanvas();
    if (!canvas) return;
    
    const mouseCoords = getCanvasRelativeCoordinates(event);
    const mouseX = mouseCoords.x;
    const mouseY = mouseCoords.y;
    
    // V√©rifier le hover sur l'isochrone
    checkIsochroneHover(mouseX, mouseY, selectedReferenceFrame, coneOrigins);
    
    if (cartoucheDragState.isDragging) {
        // Mettre √† jour l'offset du cartouche
        const deltaX = mouseX - cartoucheDragState.startX;
        const deltaY = mouseY - cartoucheDragState.startY;
        
        cartoucheOffsets[cartoucheDragState.draggedConeIndex] = {
            x: deltaX,
            y: deltaY
        };
        
        return;
    }
    
    if (dragState.isDragging) {
        const deltaX = mouseX - dragState.startX;
        const deltaY = mouseY - dragState.startY;
        
        if (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3) {
            dragState.hasActuallyDragged = true;
        }
        
        if (dragState.isNewCone) {
            // Pr√©visualiser la position du nouveau c√¥ne
            const spacetime = screenToSpacetime(mouseX, mouseY);
            const sourceCone = coneOrigins[dragState.draggedConeIndex];
            
            if (isReachableFromSource(spacetime.x, spacetime.t, sourceCone)) {
                canvas.style.cursor = 'grabbing';
            } else {
                canvas.style.cursor = 'not-allowed';
            }
        } else {
            // Mettre √† jour la position du c√¥ne existant
            const spacetime = screenToSpacetime(mouseX, mouseY);
            const cone = coneOrigins[dragState.draggedConeIndex];
            
            if (cone.sourceIndex === -1) {
                // Ne peut pas d√©placer l'origine
                return;
            }
            
            const sourceCone = coneOrigins[cone.sourceIndex];
            if (isReachableFromSource(spacetime.x, spacetime.t, sourceCone)) {
                cone.x = spacetime.x;
                cone.t = spacetime.t;
                canvas.style.cursor = 'grabbing';
            } else {
                canvas.style.cursor = 'not-allowed';
            }
        }
    } else {
        // Mettre √† jour le curseur selon la position actuelle
        const cartoucheIndex = getCartoucheAtPosition(mouseX, mouseY, getCurrentPlacements());
        if (cartoucheIndex !== -1) {
            canvas.style.cursor = 'grab';
            return;
        }
        
        const coneIndex = getConeAtPosition(mouseX, mouseY, coneOrigins);
        if (coneIndex !== -1) {
            canvas.style.cursor = 'grab';
        } else {
            const spacetime = screenToSpacetime(mouseX, mouseY);
            if (getContainingCone(spacetime.x, spacetime.t, coneOrigins) !== -1) {
                canvas.classList.add('inside-cone');
                canvas.style.cursor = '';
            } else {
                canvas.classList.remove('inside-cone');
                canvas.style.cursor = '';
            }
        }
    }
}

/**
 * Gestionnaire d'√©v√©nement mouseup
 * @param {MouseEvent} event - √âv√©nement souris
 */
export function handleMouseUp(event) {
    const canvas = getCanvas();
    if (!canvas) return;
    
    const mouseCoords = getCanvasRelativeCoordinates(event);
    const mouseX = mouseCoords.x;
    const mouseY = mouseCoords.y;
    
    if (cartoucheDragState.isDragging) {
        cartoucheDragState.isDragging = false;
        canvas.style.cursor = 'grab';
        return;
    }
    
    if (dragState.isDragging) {
        // Juste arr√™ter le drag - la cr√©ation de c√¥ne est g√©r√©e dans mouseDown
        dragState.isDragging = false;
        dragState.isNewCone = false;
        dragState.hasActuallyDragged = false;
        
        canvas.style.cursor = '';
    }
}

/**
 * Gestionnaire d'√©v√©nement click sur le canvas
 * @param {MouseEvent} event - √âv√©nement souris
 */
export function handleCanvasClick(event) {
    const mouseCoords = getCanvasRelativeCoordinates(event);
    const mouseX = mouseCoords.x;
    const mouseY = mouseCoords.y;
    
    // V√©rifier si on clique sur une origine de c√¥ne pour la s√©lectionner
    const coneIndex = getConeAtPosition(mouseX, mouseY, coneOrigins);
    if (coneIndex !== -1) {
        selectedReferenceFrame = coneIndex;
        window.selectedReferenceFrame = coneIndex;
        updateSelectedReferenceFrame(coneIndex);
        updateCalculationsDisplay();
        return;
    }
    
    // V√©rifier si on clique sur un cartouche pour le s√©lectionner
    const cartoucheIndex = getCartoucheAtPosition(mouseX, mouseY, getCurrentPlacements());
    if (cartoucheIndex !== -1) {
        selectedReferenceFrame = cartoucheIndex;
        window.selectedReferenceFrame = cartoucheIndex;
        updateSelectedReferenceFrame(cartoucheIndex);
        updateCalculationsDisplay();
        return;
    }
}

// Variables temporaires pour les placements (seront inject√©es)
let getCurrentPlacements = () => [];

/**
 * D√©finit la fonction pour obtenir les placements actuels
 * @param {Function} fn - Fonction pour obtenir les placements
 */
export function setGetCurrentPlacements(fn) {
    getCurrentPlacements = fn;
}

/**
 * Obtient l'√©tat de drag actuel
 * @returns {Object} √âtat de drag
 */
export function getDragState() {
    return dragState;
}

/**
 * Obtient l'√©tat de drag des cartouches
 * @returns {Object} √âtat de drag des cartouches
 */
export function getCartoucheDragState() {
    return cartoucheDragState;
} 